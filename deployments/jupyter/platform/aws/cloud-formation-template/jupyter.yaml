AWSTemplateFormatVersion: '2010-09-09'

Metadata:
  License: TODO
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Jupyter"
        Parameters:
          - JupyterName
          - InstanceType
          - VolumeSize
          - TerminationProtection
          - IamRole
      - Label:
          default: "Jupyter connection"
        Parameters:
          - AvailabilityZone
          - LoadBalancing
          - LoadBalancerScheme
          - Private
          - Session
          - Vpc
          - Subnet
          # - ApplicationLoadBalancerSubnets
          - KeyName
          - AccessCIDR
      - Label:
          default: "Persistent volume"
        Parameters:
          - UsePersistentVolume
          - PersistentVolumeSize
          - ExistingPersistentVolumeId
          - PersistentVolumeDeletionPolicy
      - Label:
          default: "Jupyter connection"
        Parameters:
          - JupyterToken
          - JupyterHttpPort
          - JupyterVersion

Description: >-
  AWS CloudFormation Template jupyter: a jupyter instance configured with the regulus kernel.
  Note: You will be billed for the AWS resources used if you create a stack from this template.

Parameters:

  LatestAmiId:
    Type: 'AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>'
    Default: '/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2'

  JupyterName:
    AllowedPattern: '^[a-zA-Z][a-zA-Z0-9-]*'
    ConstraintDescription: must begin with a letter and contain only alphanumeric
      characters.
    Default: jupyter
    Description: The jupyter service instance name
    MaxLength: '20'
    MinLength: '1'
    Type: String

  JupyterToken:
    Type: String
    NoEcho: true
    Description: The token or password equivalent used to access Jupyter.
    AllowedPattern: '^[a-zA-Z][a-zA-Z0-9-]*'
    ConstraintDescription: must begin with a letter and contain only alphanumeric characters.
    Description: The jupyter service instance name
    #MaxLength: '64'
    #MinLength: '16'

  Private:
    Description: Will Jupyter be deployed in a private netowrk without public IPs?
    Type: String
    Default: false
    AllowedValues:
      - true
      - false

  LoadBalancing:
    Description: |
      Will Jupyter be accessed via a ALB or NLB? 
      This Load balancer in intended to provide TLS termination and access to private networks,
      not to add multiple Jupyter instance for workload distribution.
    Type: String
    Default: NetworkLoadBalancer
    AllowedValues:
      - None
      - NetworkLoadBalancer
      # - ApplicationLoadBalancer

  LoadBalancerScheme:
    Description: |
      If using a LoadBalancer, will it be internal or internet-facing? 
      The DNS name of an Internet-facing load balancer is publicly resolvable to the public IP addresses of the nodes.
      Therefore, Internet-facing load balancers can route requests from clients over the internet. The nodes of an 
      internal load balancer have only private IP addresses. The DNS name of an internal load balancer is publicly
      resolvable to the private IP addresses of the nodes. Therefore, internal load balancers can route requests only
      from clients with access to the VPC for the load balancer.
    Type: String
    Default: internet-facing
    AllowedValues:
     - internal
     - internet-facing

  Session:
    Description: Should Jupyter be accessible via AWS Session Manager?
    Type: String
    Default: false
    AllowedValues:
      - true
      - false

  Vpc:
    ConstraintDescription: must be the name of an existing vpc.
    Description: Network to deploy the jupyter service to.
    Type: AWS::EC2::VPC::Id

  Subnet:
    ConstraintDescription: must be the name of a existing subnet.
    Description: |
      Subnetwork to deploy the Jupyter service to.
      If using an ApplicationLoadBalancer for Access, Please select at least two subnets.
    Type: AWS::EC2::Subnet::Id

  AvailabilityZone:
    ConstraintDescription: must be the name of a existing subnet.
    Description: |
      AvailabilityZ one to deploy the Jupyter service to.
      This must match the subnet, the zone of any pre existing volumes if used, 
      and the instance type must be available in the selected zone.
    Type: AWS::EC2::AvailabilityZone::Name

  # ApplicationLoadBalancerSubnets:
  #   ConstraintDescription: optional subnets if using Application Load Balancers, must be the names of existing subnets.
  #   Description: |
  #     Subnetwork(s) to deploy the Application Load Balancer to.
  #     If using an ApplicationLoadBalancer for Access, Please select at least two subnets.
  #   Type: List<AWS::EC2::Subnet::Id>
  #   Default: []

  JupyterHttpPort:
    ConstraintDescription: must be a valid ununsed port between 0 and 65535.
    Description: port to access the jupyter service ui.
    Type: Number
    Default: 8888
    MinValue: 0
    MaxValue: 65535

  JupyterVersion:
    Type: String
    Default: latest
    Description: Which version of jupyter to deploy, uses container version tags, defaults to "latest"

  RootVolumeSize:
    ConstraintDescription: Size in GB, between 10 and 1000.
    Description: size of the root disk to the jupyter server.
    Type: Number
    Default: 20
    MinValue: 8
    MaxValue: 1000

  UsePersistentVolume:
    ConstraintDescription: Specify if you are using a a new persistent volume, an existing one, or none. 
    Description: size of the optional persistent disk to the jupyter server.
    Type: String
    Default: None
    AllowedValues:
      - None
      - New
      - Existing

  PersistentVolumeSize:
    ConstraintDescription: Size in GB, between 10 and 1000.
    Description: size of the optional persistent disk to the workspaces server.
    Type: Number
    Default: 20
    MinValue: 8
    MaxValue: 1000

  ExistingPersistentVolumeId:
    Description: Id of the existing persistent volume to attach. Must be int the same availability zone as the Jupyter instance.
    Type: String
    Default: None

  # AvailabilityZone:
  #   Description: The availablity zone of the the Jupyter instance and any persistent volume if a new or existing persistent volume is used, the Jupyter subnet must be in the same availablity zone.
  #   Type: AWS::EC2::AvailabilityZone

  PersistentVolumeDeletionPolicy:
    Description: Behavior for the Persistent Volume when deleting the cloudformations deployment.
    Type: String
    AllowedValues:
      - Delete
      - Retain
      - RetainExceptOnCreate
      - Snapshot
    Default: Retain

  TerminationProtection:
    Description: Enable instance termination protection.
    Type: String
    AllowedValues:
      - true
      - false
    Default: false

  InstanceType:
    AllowedValues:
    - t2.nano
    - t2.micro
    - t2.small
    - t2.medium
    - t2.large
    - t3.nano
    - t3.micro
    - t3.small
    - t3.medium
    - t3.large
    - m3.medium
    - m3.large
    - m3.xlarge
    - m3.2xlarge
    - m4.large
    - m4.xlarge
    - m4.2xlarge
    - m4.4xlarge
    - m4.10xlarge
    - c3.large
    - c3.xlarge
    - c3.2xlarge
    - c3.4xlarge
    - c3.8xlarge
    - c4.large
    - c4.xlarge
    - c4.2xlarge
    - c4.4xlarge
    - c4.8xlarge
    - r3.large
    - r3.xlarge
    - r3.2xlarge
    - r3.4xlarge
    - r3.8xlarge
    - i2.xlarge
    - i2.2xlarge
    - i2.4xlarge
    - i2.8xlarge
    ConstraintDescription: must be a valid EC2 instance type.
    Default: t2.micro
    Description: jupyter EC2 instance type
    Type: String

  KeyName:
    Description: Name of an existing EC2 KeyPair to enable SSH access to the instances, leave empty if no ssh keys should be included
    Type: String

  IamRole:
    Description: Name of an existing IAM Role to assign to Jupyter, leave empty to automatically create a compatible role.
    Type: String

  AccessCIDR:
    AllowedPattern: (\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})\/(\d{1,2})
    ConstraintDescription: must be a valid IP CIDR range of the form x.x.x.x/x.
    Default: 0.0.0.0/0
    Description: The IP address range that can be used to communicate with the Jupyter instance.
    MaxLength: '18'
    MinLength: '9'
    Type: String

Rules:
  subnetsInVpc:
    Assertions:
      - Assert:
          Fn::EachMemberEquals:
            - Fn::ValueOfAll:
              - AWS::EC2::Subnet::Id
              - VpcId
            - !Ref Vpc
        AssertDescription: The subnet you selected is not in the VPC
  instanceTypeInZone:
    Assertions:
      - Assert:
          Fn::EachMemberEquals:
            - Fn::ValueOfAll:
              - AWS::EC2::Subnet::Id
              - VpcId
            - !Ref Vpc
        AssertDescription: The subnet you selected is not in the VPC

Conditions:

  HASALB:
    !Equals [!Ref LoadBalancing, 'ApplicationLoadBalancer' ]

  HASNLB:
    !Equals [!Ref LoadBalancing, 'NetworkLoadBalancer' ]

  HASLB: !Or
    - !Condition HASALB
    - !Condition HASNLB

  NEEDSROLE:
    !Equals [!Ref IamRole, '' ]

  HASPUBLICIP:
    !Not [ !Equals [ !Ref Private, 'true' ] ]

  HASKEY:
    !Not [ !Equals [ !Ref KeyName, '' ] ]

  HASCIDRANDLB: !And
    - !Condition HASLB
    - !Condition HASCIDR

  HASCIDR:
    !Not [ !Equals [!Ref AccessCIDR, '' ] ]

  USESESSIONMANAGER:
    !Equals [ !Ref Session, 'true' ]

  NEEDSROLEANDSESSIONMANAGER: !And
    - !Condition NEEDSROLE
    - !Condition USESESSIONMANAGER

  NEEDINSTANCEPROFILE: !Or
    - !Not [ !Condition NEEDSROLE ]
    - !Condition NEEDSROLEANDSESSIONMANAGER

  HASKEYANDCIDR: !And
    - !Condition HASKEY
    - !Condition HASCIDR

  HASKEYANDPUBLIC: !And
    - !Condition HASKEY
    - !Condition HASPUBLICIP

  USENEWPERSISTENTVOLUME:
    !Equals [ !Ref UsePersistentVolume, 'New' ]

  USEEXISTINGPERSISTENTVOLUME:
    !Equals [ !Ref UsePersistentVolume, 'Existing' ]

  USEPERSISTENTVOLUME: !Or
    - !Condition USENEWPERSISTENTVOLUME
    - !Condition USEEXISTINGPERSISTENTVOLUME

Resources:

  JupyterVolume:
    Condition: USENEWPERSISTENTVOLUME
    Type: AWS::EC2::Volume
    DeletionPolicy: !Ref PersistentVolumeDeletionPolicy
    Properties: 
      AvailabilityZone: !Ref AvailabilityZone
      Size: !Ref PersistentVolumeSize
      Encrypted: true
      Tags: 
        - Key: Name
          Value: !Ref JupyterName
        - Key: Usage
          Value: persistent storage

  JupyterServer:
    Type: AWS::EC2::Instance
    CreationPolicy:
      ResourceSignal:
        Timeout: PT15M
    Metadata:
      AWS::CloudFormation::Init:
        configSets:
          jupyter_install:
            - prepare_directory
            - Fn::If: 
                - USENEWPERSISTENTVOLUME
                - prepare_new_storage
                - !Ref AWS::NoValue
            - Fn::If: 
              - USEPERSISTENTVOLUME
              - mount_storage
              - !Ref AWS::NoValue
            - install_docker
            - configure_jupyter_service
            - start_jupyter_service
        prepare_directory:
          commands:
            1_mkdir:
              command: mkdir -p /etc/td
        prepare_new_storage:
          commands:
            1_mkfs:
              command: mkfs -t ext4 /dev/nvme1n1
        mount_storage:
            1_fstab:
              command: echo "/dev/nvme1n1 /etc/td ext4 defaults 0 2" >> /etc/fstab
            2_mount:
              command: mount -a
        install_docker:
          commands:
            install_docker:
              command: !Sub |
                #!/bin/bash -xe
                amazon-linux-extras install docker -y
                amazon-linux-extras enable docker
          services:
            systemd:
              docker:
                enabled: "true"
                ensureRunning: "true"
        configure_jupyter_service:
          files:
            /usr/lib/systemd/system/jupyter.service:
              content: !Sub |
                [Unit]
                Description=jupyter
                After=docker.service
                Requires=docker.service
                StartLimitInterval=200
                StartLimitBurst=10

                [Service]
                TimeoutStartSec=0
                Restart=always
                RestartSec=2
                ExecStartPre=-/usr/bin/mkdir -p /etc/td/jupyter
                ExecStartPre=-/usr/bin/docker exec %n stop || true
                ExecStartPre=-/usr/bin/docker rm %n || true
                ExecStartPre=/usr/bin/docker pull teradata/regulus-jupyter:${ JupyterVersion }
                ExecStart=/usr/bin/docker run \
                    -e accept_license=Y \
                    -e JUPYTER_TOKEN=${ JupyterToken } \
                    -v /etc/td/jupyter:/home/jovyan/JupyterLabRoot/userdata \
                    -p ${ JupyterHttpPort }:8888 \
                    --rm --name %n teradata/regulus-jupyter:${ JupyterVersion }

                [Install]
                WantedBy=multi-user.target
              group: root
              mode: '000400'
              owner: root
        start_jupyter_service:
          services:
            systemd:
              jupyter:
                enabled: "true"
                ensureRunning: "true"
    Properties:
      PropagateTagsToVolumeOnCreation: true
      BlockDeviceMappings:
        - DeviceName: /dev/xvda
          Ebs:
            VolumeSize: !Ref RootVolumeSize
            Encrypted: true
      SubnetId: !Ref Subnet
      ImageId: !Ref LatestAmiId
      InstanceType: !Ref InstanceType
      KeyName:
        Fn::If:
        - HASKEY
        - !Ref KeyName
        - !Ref AWS::NoValue
      DisableApiTermination: !Ref TerminationProtection
      SecurityGroupIds: [!GetAtt JupyterSecurityGroup.GroupId] 
      IamInstanceProfile: 
        Fn::If:
        - NEEDINSTANCEPROFILE
        - Ref: JupyterInstanceProfile
        - Ref: AWS::NoValue
      Volumes:
        - Fn::If:
          - USEPERSISTENTVOLUME
          - Device: /dev/xvdb
            VolumeId: 
              Fn::If:
              - USENEWPERSISTENTVOLUME
              - !Ref JupyterVolume
              - !Ref ExistingPersistentVolumeId
          - !Ref AWS::NoValue
      Tags: 
        - Key: Name
          Value: !Ref JupyterName
      UserData:
        Fn::Base64: !Sub |
           #!/bin/bash -xe
           yum update -y
           yum update -y aws-cfn-bootstrap
           /opt/aws/bin/cfn-init -v --stack ${AWS::StackId} --resource JupyterServer --configsets jupyter_install --region ${AWS::Region}
           /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackId} --resource JupyterServer --region ${AWS::Region}

  LoadBalancerSecurityGroup:
    Condition: HASCIDRANDLB
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref Vpc
      GroupDescription: "Enable access to Jupyter server from LoadBalancer over http, grpc, and ssh"
      SecurityGroupIngress:
      - CidrIp: !Ref AccessCIDR
        FromPort: !Ref JupyterHttpPort
        IpProtocol: tcp
        ToPort: !Ref JupyterHttpPort

  LoadBalancer:
    Condition: HASLB
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Scheme: internet-facing
      Subnets: [ !Ref Subnet ]
      SecurityGroups:
        - !GetAtt LoadBalancerSecurityGroup.GroupId
      Type: 
        Fn::If:
          - HASALB
          - application
          - network

  JupyterHTTPListener:
    Condition: HASLB
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: 
            Fn::If:
              - HASALB
              - !Ref JupyterALBHTTPTargetGroup
              - !Ref JupyterNLBHTTPTargetGroup
      LoadBalancerArn: !Ref LoadBalancer
      Port: !Ref JupyterHttpPort
      Protocol: 
        Fn::If:
          - HASALB
          - HTTP
          - TCP

  JupyterALBHTTPTargetGroup:
    Condition: HASALB
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 30
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 15
      Matcher:
        HttpCode: '200'
      Name: !Sub "${JupyterName}-j-http"
      Port: !Ref JupyterHttpPort
      Protocol: HTTP
      TargetGroupAttributes:
      - Key: stickiness.enabled
        Value: true
      - Key: stickiness.type
        Value: app_cookie 
      - Key: stickiness.app_cookie.cookie_name
        Value: TDJUPYTERHTTPSSESSION
      - Key: deregistration_delay.timeout_seconds
        Value: '20'
      Targets:
      - Id: !Ref JupyterServer
        Port: !Ref JupyterHttpPort
      VpcId: !Ref Vpc

  JupyterNLBHTTPTargetGroup:
    Condition: HASNLB
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      HealthCheckIntervalSeconds: 30
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 15
      Name: !Sub "${JupyterName}-j-http"
      Port: !Ref JupyterHttpPort
      Protocol: TCP
      TargetGroupAttributes:
      - Key: stickiness.enabled
        Value: true
      - Key: stickiness.type
        Value: source_ip
      - Key: deregistration_delay.timeout_seconds
        Value: '20'
      Targets:
      - Id: !Ref JupyterServer
        Port: !Ref JupyterHttpPort
      VpcId: !Ref Vpc

  JupyterSecurityGroup:
    Condition: HASCIDR
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref Vpc
      GroupDescription: "Enable access to jupyter server over http"
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: !Ref JupyterHttpPort
          ToPort: !Ref JupyterHttpPort
          SourceSecurityGroupId: 
            Fn::If:
              - HASLB
              - Fn::GetAtt:
                  - LoadBalancerSecurityGroup
                  - GroupId
              - !Ref AWS::NoValue
          CidrIp: 
            Fn::If:
              - HASLB
              - !Ref AWS::NoValue
              - !Ref AccessCIDR

  SecurityGroupIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Condition: HASKEYANDCIDR
    Properties: 
      GroupId: !GetAtt JupyterSecurityGroup.GroupId
      CidrIp: !Ref AccessCIDR
      FromPort: 22
      IpProtocol: tcp
      ToPort: 22

  JupyterRole:
    Condition: NEEDSROLEANDSESSIONMANAGER
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - ec2.amazonaws.com
          Action:
          - sts:AssumeRole
      Path: "/"

  SessionManagerPolicies:
    Condition: NEEDSROLEANDSESSIONMANAGER
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: JupyterSessionManagerPolicy
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Action: 
          - "ssm:DescribeAssociation"
          - "ssm:GetDeployablePatchSnapshotForInstance"
          - "ssm:GetDocument"
          - "ssm:DescribeDocument"
          - "ssm:GetManifest"
          - "ssm:ListAssociations"
          - "ssm:ListInstanceAssociations"
          - "ssm:PutInventory"
          - "ssm:PutComplianceItems"
          - "ssm:PutConfigurePackageResult"
          - "ssm:UpdateAssociationStatus"
          - "ssm:UpdateInstanceAssociationStatus"
          - "ssm:UpdateInstanceInformation"
          Resource: "*"
        - Effect: Allow
          Action: 
          - "ssmmessages:CreateControlChannel"
          - "ssmmessages:CreateDataChannel"
          - "ssmmessages:OpenControlChannel"
          - "ssmmessages:OpenDataChannel"
          Resource: "*"
        - Effect: Allow
          Action: 
          - "ec2messages:AcknowledgeMessage"
          - "ec2messages:DeleteMessage"
          - "ec2messages:FailMessage"
          - "ec2messages:GetEndpoint"
          - "ec2messages:GetMessages"
          - "ec2messages:SendReply"
          Resource: "*"
      Roles:
      - !Ref JupyterRole

  JupyterInstanceProfile:
    Condition: NEEDINSTANCEPROFILE
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: "/"
      Roles:
        Fn::If:
        - NEEDSROLEANDSESSIONMANAGER
        - [ Ref: JupyterRole ]
        - [ Ref: IamRole ]

Outputs:
  PublicIP:
    Condition: HASPUBLICIP 
    Description: EC2 public IP
    Value: !GetAtt JupyterServer.PublicIp

  PrivateIP:
    Description: EC2 private IP
    Value: !GetAtt JupyterServer.PrivateIp

  LoadBalancerJupyterUIAccess:
    Condition: HASLB
    Description: Loadbalancer access endpoint for API Access
    Value: !Sub "${ LoadBalancer.DNSName }:${ JupyterHttpPort }?token=${ JupyterToken }"

  JupyterPublicHttpAccess:
    Condition: HASPUBLICIP 
    Description: Teradata Jupyter Server
    Value: !Sub "http://${JupyterServer.PublicDnsName}:${ JupyterHttpPort }?token=${ JupyterToken }"

  JupyterPrivateHttpAccess:
    Description: Teradata jupyter Server
    Value: !Sub "http://${JupyterServer.PrivateDnsName}:${ JupyterHttpPort }?token=${ JupyterToken }"

  SecurityGroup:
    Description: Jupyter Security Group
    Value: !GetAtt JupyterSecurityGroup.GroupId

  PublicSSHConeection:
    Condition: HASKEYANDPUBLIC
    Description: Jupyter ssh connnection string
    Value: !Sub "ssh ec2-user@${ JupyterServer.PublicIp }"

  PrivateSSHConeection:
    Condition: HASKEY
    Description: jupyter ssh connnection string
    Value: !Sub "ssh ec2-user@${ JupyterServer.PrivateIp }"

  PersistentVolumeId:
    Condition: USENEWPERSISTENTVOLUME
    Description: Id of the new persistent volume created for Jupyter
    Value: !Ref JupyterVolume
